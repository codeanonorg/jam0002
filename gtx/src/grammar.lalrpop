use std::rc::Rc;
use crate::loc::{Span, Located};
use crate::parser::ReplParse;
use crate::ast::*;

grammar(file_id: codespan::FileId);

extern {
    type Location = usize;
}

match {
    "case",
    "of",
    "end",
    "rematch",
    "match",
    r"[A-Z0-9_][a-zA-Z0-9_]*" => "CONSTR",
} else {
    r"[a-z_][a-zA-Z0-9_]*" => "IDENT",
    _
}

pub Toplevel = { <Decl*> }

pub Repl: Located<ReplParse> = {
    <Decl> => <>.map(ReplParse::Decl),
    <Expr> => <>.map(ReplParse::Expr),
}

Decl: Located<Decl> = {
    <name:Located<Ident>> "=" <body:Expr> => Located {
        file_id,
        span: name.span().merge(body.span()),
        value: Decl {
            name,
            body,
        }
    }
}

Expr: Located<Expr> = {
    <l:@L> "case" <on:RawExpr> "of" <arms:Clause*> "end" <r:@R> =>
        Located {
            span: Span(l, r),
            file_id,
            value: Expr::Match {
                on: on.map(Rc::new),
                arms
            },
        },
    RawExpr,
}

Tier<Op, Next>: Located<Expr> = {
    <l:Tier<Op, Next>> <op:Op> <r:Next> => Located {
        file_id,
        span: l.span().merge(r.span()),
        value: Expr::Binop {
            lhs: l.map(Rc::new),
            op,
            rhs: r.map(Rc::new),
        },
    },
    Next,
}

RawExpr = Tier<ExprOp, Factor>;
Factor = Tier<FactorOp, Atom>;

ExprOp: Located<Binop> = {
    Located<"+"> => <>.map(|_| Binop::Add),
    Located<"-"> => <>.map(|_| Binop::Sub),
}
FactorOp: Located<Binop> = {
    Located<"*"> => <>.map(|_| Binop::Mul),
    Located<"/"> => <>.map(|_| Binop::Div),
}

Atom: Located<Expr> = {
    Prim => <>.map(Expr::Pattern),
    "(" <Expr> ")",
}

Clause: Clause = {
    "|" <pattern:Prim> <recursive:MatchKind> <body:Expr> => {
        Clause {
            recursive,
            pattern,
            body,
        }
    }
}

MatchKind: bool = {
    "match" => false,
    "rematch" => true,
}

Prim: Located<Pattern> = {
    Located<Ident> => <>.map(Pattern::Var),
    <l:@L> <name: Located<Constr>> <r:@R> => Located {
        value: Pattern::Constructor {
            name,
            args: vec![],
        },
        file_id,
        span: Span(l, r),
    },
    <l:@L> <name:Located<Constr>> "(" <args:Comma<Prim>> ")" <r:@R> => Located {
        file_id,
        span: Span(l, r),
        value: Pattern::Constructor {
            name,
            args,
        }
    },
}

Comma<T>: Vec<T> = {
    <x:T> "," <xs:T+> => std::iter::once(x).chain(xs.into_iter()).collect(),
    <x:T> => vec![x],
}

Constr: String = { <"CONSTR"> => <>.to_string() }
Ident: String = { <"IDENT"> => <>.to_string() }

Located<T>: Located<T> = {
    <l:@L> <value:T> <r:@R> => Located {
        file_id,
        span: Span(l, r),
        value,
    }
}